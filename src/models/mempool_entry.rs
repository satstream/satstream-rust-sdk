/* 
 * Satstream API
 *
 * Satstream API
 *
 * OpenAPI spec version: 1.0
 * Contact: team@satstream.io
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct MempoolEntry {
  /// Number of in-mempool ancestor transactions
  #[serde(rename = "ancestorcount")]
  ancestorcount: Option<i32>,
  /// Virtual size of in-mempool ancestors
  #[serde(rename = "ancestorsize")]
  ancestorsize: Option<i32>,
  /// Whether this transaction is replaceable
  #[serde(rename = "bip125-replaceable")]
  bip125_replaceable: Option<bool>,
  /// Parent transaction IDs
  #[serde(rename = "depends")]
  depends: Option<Vec<String>>,
  /// Number of in-mempool descendant transactions
  #[serde(rename = "descendantcount")]
  descendantcount: Option<i32>,
  /// Virtual size of in-mempool descendants
  #[serde(rename = "descendantsize")]
  descendantsize: Option<i32>,
  #[serde(rename = "fees")]
  fees: Option<::models::MempoolEntryFees>,
  /// Block height when transaction entered pool
  #[serde(rename = "height")]
  height: Option<i32>,
  /// Child transaction IDs
  #[serde(rename = "spentby")]
  spentby: Option<Vec<String>>,
  /// Time transaction entered pool
  #[serde(rename = "time")]
  time: Option<i32>,
  /// Whether this transaction is currently unbroadcast
  #[serde(rename = "unbroadcast")]
  unbroadcast: Option<bool>,
  /// Virtual transaction size
  #[serde(rename = "vsize")]
  vsize: Option<i32>,
  /// Transaction weight
  #[serde(rename = "weight")]
  weight: Option<i32>,
  /// Hash of serialized transaction with witness data
  #[serde(rename = "wtxid")]
  wtxid: Option<String>
}

impl MempoolEntry {
  pub fn new() -> MempoolEntry {
    MempoolEntry {
      ancestorcount: None,
      ancestorsize: None,
      bip125_replaceable: None,
      depends: None,
      descendantcount: None,
      descendantsize: None,
      fees: None,
      height: None,
      spentby: None,
      time: None,
      unbroadcast: None,
      vsize: None,
      weight: None,
      wtxid: None
    }
  }

  pub fn set_ancestorcount(&mut self, ancestorcount: i32) {
    self.ancestorcount = Some(ancestorcount);
  }

  pub fn with_ancestorcount(mut self, ancestorcount: i32) -> MempoolEntry {
    self.ancestorcount = Some(ancestorcount);
    self
  }

  pub fn ancestorcount(&self) -> Option<&i32> {
    self.ancestorcount.as_ref()
  }

  pub fn reset_ancestorcount(&mut self) {
    self.ancestorcount = None;
  }

  pub fn set_ancestorsize(&mut self, ancestorsize: i32) {
    self.ancestorsize = Some(ancestorsize);
  }

  pub fn with_ancestorsize(mut self, ancestorsize: i32) -> MempoolEntry {
    self.ancestorsize = Some(ancestorsize);
    self
  }

  pub fn ancestorsize(&self) -> Option<&i32> {
    self.ancestorsize.as_ref()
  }

  pub fn reset_ancestorsize(&mut self) {
    self.ancestorsize = None;
  }

  pub fn set_bip125_replaceable(&mut self, bip125_replaceable: bool) {
    self.bip125_replaceable = Some(bip125_replaceable);
  }

  pub fn with_bip125_replaceable(mut self, bip125_replaceable: bool) -> MempoolEntry {
    self.bip125_replaceable = Some(bip125_replaceable);
    self
  }

  pub fn bip125_replaceable(&self) -> Option<&bool> {
    self.bip125_replaceable.as_ref()
  }

  pub fn reset_bip125_replaceable(&mut self) {
    self.bip125_replaceable = None;
  }

  pub fn set_depends(&mut self, depends: Vec<String>) {
    self.depends = Some(depends);
  }

  pub fn with_depends(mut self, depends: Vec<String>) -> MempoolEntry {
    self.depends = Some(depends);
    self
  }

  pub fn depends(&self) -> Option<&Vec<String>> {
    self.depends.as_ref()
  }

  pub fn reset_depends(&mut self) {
    self.depends = None;
  }

  pub fn set_descendantcount(&mut self, descendantcount: i32) {
    self.descendantcount = Some(descendantcount);
  }

  pub fn with_descendantcount(mut self, descendantcount: i32) -> MempoolEntry {
    self.descendantcount = Some(descendantcount);
    self
  }

  pub fn descendantcount(&self) -> Option<&i32> {
    self.descendantcount.as_ref()
  }

  pub fn reset_descendantcount(&mut self) {
    self.descendantcount = None;
  }

  pub fn set_descendantsize(&mut self, descendantsize: i32) {
    self.descendantsize = Some(descendantsize);
  }

  pub fn with_descendantsize(mut self, descendantsize: i32) -> MempoolEntry {
    self.descendantsize = Some(descendantsize);
    self
  }

  pub fn descendantsize(&self) -> Option<&i32> {
    self.descendantsize.as_ref()
  }

  pub fn reset_descendantsize(&mut self) {
    self.descendantsize = None;
  }

  pub fn set_fees(&mut self, fees: ::models::MempoolEntryFees) {
    self.fees = Some(fees);
  }

  pub fn with_fees(mut self, fees: ::models::MempoolEntryFees) -> MempoolEntry {
    self.fees = Some(fees);
    self
  }

  pub fn fees(&self) -> Option<&::models::MempoolEntryFees> {
    self.fees.as_ref()
  }

  pub fn reset_fees(&mut self) {
    self.fees = None;
  }

  pub fn set_height(&mut self, height: i32) {
    self.height = Some(height);
  }

  pub fn with_height(mut self, height: i32) -> MempoolEntry {
    self.height = Some(height);
    self
  }

  pub fn height(&self) -> Option<&i32> {
    self.height.as_ref()
  }

  pub fn reset_height(&mut self) {
    self.height = None;
  }

  pub fn set_spentby(&mut self, spentby: Vec<String>) {
    self.spentby = Some(spentby);
  }

  pub fn with_spentby(mut self, spentby: Vec<String>) -> MempoolEntry {
    self.spentby = Some(spentby);
    self
  }

  pub fn spentby(&self) -> Option<&Vec<String>> {
    self.spentby.as_ref()
  }

  pub fn reset_spentby(&mut self) {
    self.spentby = None;
  }

  pub fn set_time(&mut self, time: i32) {
    self.time = Some(time);
  }

  pub fn with_time(mut self, time: i32) -> MempoolEntry {
    self.time = Some(time);
    self
  }

  pub fn time(&self) -> Option<&i32> {
    self.time.as_ref()
  }

  pub fn reset_time(&mut self) {
    self.time = None;
  }

  pub fn set_unbroadcast(&mut self, unbroadcast: bool) {
    self.unbroadcast = Some(unbroadcast);
  }

  pub fn with_unbroadcast(mut self, unbroadcast: bool) -> MempoolEntry {
    self.unbroadcast = Some(unbroadcast);
    self
  }

  pub fn unbroadcast(&self) -> Option<&bool> {
    self.unbroadcast.as_ref()
  }

  pub fn reset_unbroadcast(&mut self) {
    self.unbroadcast = None;
  }

  pub fn set_vsize(&mut self, vsize: i32) {
    self.vsize = Some(vsize);
  }

  pub fn with_vsize(mut self, vsize: i32) -> MempoolEntry {
    self.vsize = Some(vsize);
    self
  }

  pub fn vsize(&self) -> Option<&i32> {
    self.vsize.as_ref()
  }

  pub fn reset_vsize(&mut self) {
    self.vsize = None;
  }

  pub fn set_weight(&mut self, weight: i32) {
    self.weight = Some(weight);
  }

  pub fn with_weight(mut self, weight: i32) -> MempoolEntry {
    self.weight = Some(weight);
    self
  }

  pub fn weight(&self) -> Option<&i32> {
    self.weight.as_ref()
  }

  pub fn reset_weight(&mut self) {
    self.weight = None;
  }

  pub fn set_wtxid(&mut self, wtxid: String) {
    self.wtxid = Some(wtxid);
  }

  pub fn with_wtxid(mut self, wtxid: String) -> MempoolEntry {
    self.wtxid = Some(wtxid);
    self
  }

  pub fn wtxid(&self) -> Option<&String> {
    self.wtxid.as_ref()
  }

  pub fn reset_wtxid(&mut self) {
    self.wtxid = None;
  }

}



