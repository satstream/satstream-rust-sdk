/* 
 * Satstream API
 *
 * Satstream API
 *
 * OpenAPI spec version: 1.0
 * Contact: team@satstream.io
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct BtcTx3 {
  #[serde(rename = "fee")]
  fee: Option<f32>,
  #[serde(rename = "hash")]
  hash: Option<String>,
  #[serde(rename = "hex")]
  hex: Option<String>,
  #[serde(rename = "locktime")]
  locktime: Option<i32>,
  #[serde(rename = "size")]
  size: Option<i32>,
  #[serde(rename = "txid")]
  txid: Option<String>,
  #[serde(rename = "version")]
  version: Option<i32>,
  #[serde(rename = "vin")]
  vin: Option<Vec<::models::BlockVin3>>,
  #[serde(rename = "vout")]
  vout: Option<Vec<::models::Vout>>,
  #[serde(rename = "vsize")]
  vsize: Option<i32>,
  #[serde(rename = "weight")]
  weight: Option<i32>
}

impl BtcTx3 {
  pub fn new() -> BtcTx3 {
    BtcTx3 {
      fee: None,
      hash: None,
      hex: None,
      locktime: None,
      size: None,
      txid: None,
      version: None,
      vin: None,
      vout: None,
      vsize: None,
      weight: None
    }
  }

  pub fn set_fee(&mut self, fee: f32) {
    self.fee = Some(fee);
  }

  pub fn with_fee(mut self, fee: f32) -> BtcTx3 {
    self.fee = Some(fee);
    self
  }

  pub fn fee(&self) -> Option<&f32> {
    self.fee.as_ref()
  }

  pub fn reset_fee(&mut self) {
    self.fee = None;
  }

  pub fn set_hash(&mut self, hash: String) {
    self.hash = Some(hash);
  }

  pub fn with_hash(mut self, hash: String) -> BtcTx3 {
    self.hash = Some(hash);
    self
  }

  pub fn hash(&self) -> Option<&String> {
    self.hash.as_ref()
  }

  pub fn reset_hash(&mut self) {
    self.hash = None;
  }

  pub fn set_hex(&mut self, hex: String) {
    self.hex = Some(hex);
  }

  pub fn with_hex(mut self, hex: String) -> BtcTx3 {
    self.hex = Some(hex);
    self
  }

  pub fn hex(&self) -> Option<&String> {
    self.hex.as_ref()
  }

  pub fn reset_hex(&mut self) {
    self.hex = None;
  }

  pub fn set_locktime(&mut self, locktime: i32) {
    self.locktime = Some(locktime);
  }

  pub fn with_locktime(mut self, locktime: i32) -> BtcTx3 {
    self.locktime = Some(locktime);
    self
  }

  pub fn locktime(&self) -> Option<&i32> {
    self.locktime.as_ref()
  }

  pub fn reset_locktime(&mut self) {
    self.locktime = None;
  }

  pub fn set_size(&mut self, size: i32) {
    self.size = Some(size);
  }

  pub fn with_size(mut self, size: i32) -> BtcTx3 {
    self.size = Some(size);
    self
  }

  pub fn size(&self) -> Option<&i32> {
    self.size.as_ref()
  }

  pub fn reset_size(&mut self) {
    self.size = None;
  }

  pub fn set_txid(&mut self, txid: String) {
    self.txid = Some(txid);
  }

  pub fn with_txid(mut self, txid: String) -> BtcTx3 {
    self.txid = Some(txid);
    self
  }

  pub fn txid(&self) -> Option<&String> {
    self.txid.as_ref()
  }

  pub fn reset_txid(&mut self) {
    self.txid = None;
  }

  pub fn set_version(&mut self, version: i32) {
    self.version = Some(version);
  }

  pub fn with_version(mut self, version: i32) -> BtcTx3 {
    self.version = Some(version);
    self
  }

  pub fn version(&self) -> Option<&i32> {
    self.version.as_ref()
  }

  pub fn reset_version(&mut self) {
    self.version = None;
  }

  pub fn set_vin(&mut self, vin: Vec<::models::BlockVin3>) {
    self.vin = Some(vin);
  }

  pub fn with_vin(mut self, vin: Vec<::models::BlockVin3>) -> BtcTx3 {
    self.vin = Some(vin);
    self
  }

  pub fn vin(&self) -> Option<&Vec<::models::BlockVin3>> {
    self.vin.as_ref()
  }

  pub fn reset_vin(&mut self) {
    self.vin = None;
  }

  pub fn set_vout(&mut self, vout: Vec<::models::Vout>) {
    self.vout = Some(vout);
  }

  pub fn with_vout(mut self, vout: Vec<::models::Vout>) -> BtcTx3 {
    self.vout = Some(vout);
    self
  }

  pub fn vout(&self) -> Option<&Vec<::models::Vout>> {
    self.vout.as_ref()
  }

  pub fn reset_vout(&mut self) {
    self.vout = None;
  }

  pub fn set_vsize(&mut self, vsize: i32) {
    self.vsize = Some(vsize);
  }

  pub fn with_vsize(mut self, vsize: i32) -> BtcTx3 {
    self.vsize = Some(vsize);
    self
  }

  pub fn vsize(&self) -> Option<&i32> {
    self.vsize.as_ref()
  }

  pub fn reset_vsize(&mut self) {
    self.vsize = None;
  }

  pub fn set_weight(&mut self, weight: i32) {
    self.weight = Some(weight);
  }

  pub fn with_weight(mut self, weight: i32) -> BtcTx3 {
    self.weight = Some(weight);
    self
  }

  pub fn weight(&self) -> Option<&i32> {
    self.weight.as_ref()
  }

  pub fn reset_weight(&mut self) {
    self.weight = None;
  }

}



