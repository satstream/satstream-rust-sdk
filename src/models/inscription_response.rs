/* 
 * Satstream API
 *
 * Satstream API
 *
 * OpenAPI spec version: 1.0
 * Contact: team@satstream.io
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct InscriptionResponse {
  #[serde(rename = "address")]
  address: Option<String>,
  #[serde(rename = "charms")]
  charms: Option<Vec<String>>,
  #[serde(rename = "children")]
  children: Option<Vec<String>>,
  #[serde(rename = "content_length")]
  content_length: Option<i32>,
  #[serde(rename = "content_type")]
  content_type: Option<String>,
  #[serde(rename = "effective_content_type")]
  effective_content_type: Option<String>,
  #[serde(rename = "fee")]
  fee: Option<i32>,
  #[serde(rename = "height")]
  height: Option<i32>,
  #[serde(rename = "id")]
  id: Option<String>,
  #[serde(rename = "next")]
  next: Option<String>,
  #[serde(rename = "number")]
  number: Option<i32>,
  #[serde(rename = "parents")]
  parents: Option<Vec<String>>,
  #[serde(rename = "previous")]
  previous: Option<String>,
  #[serde(rename = "rune")]
  rune: Option<String>,
  #[serde(rename = "sat")]
  sat: Option<String>,
  #[serde(rename = "satpoint")]
  satpoint: Option<String>,
  #[serde(rename = "timestamp")]
  timestamp: Option<i32>,
  #[serde(rename = "value")]
  value: Option<i32>
}

impl InscriptionResponse {
  pub fn new() -> InscriptionResponse {
    InscriptionResponse {
      address: None,
      charms: None,
      children: None,
      content_length: None,
      content_type: None,
      effective_content_type: None,
      fee: None,
      height: None,
      id: None,
      next: None,
      number: None,
      parents: None,
      previous: None,
      rune: None,
      sat: None,
      satpoint: None,
      timestamp: None,
      value: None
    }
  }

  pub fn set_address(&mut self, address: String) {
    self.address = Some(address);
  }

  pub fn with_address(mut self, address: String) -> InscriptionResponse {
    self.address = Some(address);
    self
  }

  pub fn address(&self) -> Option<&String> {
    self.address.as_ref()
  }

  pub fn reset_address(&mut self) {
    self.address = None;
  }

  pub fn set_charms(&mut self, charms: Vec<String>) {
    self.charms = Some(charms);
  }

  pub fn with_charms(mut self, charms: Vec<String>) -> InscriptionResponse {
    self.charms = Some(charms);
    self
  }

  pub fn charms(&self) -> Option<&Vec<String>> {
    self.charms.as_ref()
  }

  pub fn reset_charms(&mut self) {
    self.charms = None;
  }

  pub fn set_children(&mut self, children: Vec<String>) {
    self.children = Some(children);
  }

  pub fn with_children(mut self, children: Vec<String>) -> InscriptionResponse {
    self.children = Some(children);
    self
  }

  pub fn children(&self) -> Option<&Vec<String>> {
    self.children.as_ref()
  }

  pub fn reset_children(&mut self) {
    self.children = None;
  }

  pub fn set_content_length(&mut self, content_length: i32) {
    self.content_length = Some(content_length);
  }

  pub fn with_content_length(mut self, content_length: i32) -> InscriptionResponse {
    self.content_length = Some(content_length);
    self
  }

  pub fn content_length(&self) -> Option<&i32> {
    self.content_length.as_ref()
  }

  pub fn reset_content_length(&mut self) {
    self.content_length = None;
  }

  pub fn set_content_type(&mut self, content_type: String) {
    self.content_type = Some(content_type);
  }

  pub fn with_content_type(mut self, content_type: String) -> InscriptionResponse {
    self.content_type = Some(content_type);
    self
  }

  pub fn content_type(&self) -> Option<&String> {
    self.content_type.as_ref()
  }

  pub fn reset_content_type(&mut self) {
    self.content_type = None;
  }

  pub fn set_effective_content_type(&mut self, effective_content_type: String) {
    self.effective_content_type = Some(effective_content_type);
  }

  pub fn with_effective_content_type(mut self, effective_content_type: String) -> InscriptionResponse {
    self.effective_content_type = Some(effective_content_type);
    self
  }

  pub fn effective_content_type(&self) -> Option<&String> {
    self.effective_content_type.as_ref()
  }

  pub fn reset_effective_content_type(&mut self) {
    self.effective_content_type = None;
  }

  pub fn set_fee(&mut self, fee: i32) {
    self.fee = Some(fee);
  }

  pub fn with_fee(mut self, fee: i32) -> InscriptionResponse {
    self.fee = Some(fee);
    self
  }

  pub fn fee(&self) -> Option<&i32> {
    self.fee.as_ref()
  }

  pub fn reset_fee(&mut self) {
    self.fee = None;
  }

  pub fn set_height(&mut self, height: i32) {
    self.height = Some(height);
  }

  pub fn with_height(mut self, height: i32) -> InscriptionResponse {
    self.height = Some(height);
    self
  }

  pub fn height(&self) -> Option<&i32> {
    self.height.as_ref()
  }

  pub fn reset_height(&mut self) {
    self.height = None;
  }

  pub fn set_id(&mut self, id: String) {
    self.id = Some(id);
  }

  pub fn with_id(mut self, id: String) -> InscriptionResponse {
    self.id = Some(id);
    self
  }

  pub fn id(&self) -> Option<&String> {
    self.id.as_ref()
  }

  pub fn reset_id(&mut self) {
    self.id = None;
  }

  pub fn set_next(&mut self, next: String) {
    self.next = Some(next);
  }

  pub fn with_next(mut self, next: String) -> InscriptionResponse {
    self.next = Some(next);
    self
  }

  pub fn next(&self) -> Option<&String> {
    self.next.as_ref()
  }

  pub fn reset_next(&mut self) {
    self.next = None;
  }

  pub fn set_number(&mut self, number: i32) {
    self.number = Some(number);
  }

  pub fn with_number(mut self, number: i32) -> InscriptionResponse {
    self.number = Some(number);
    self
  }

  pub fn number(&self) -> Option<&i32> {
    self.number.as_ref()
  }

  pub fn reset_number(&mut self) {
    self.number = None;
  }

  pub fn set_parents(&mut self, parents: Vec<String>) {
    self.parents = Some(parents);
  }

  pub fn with_parents(mut self, parents: Vec<String>) -> InscriptionResponse {
    self.parents = Some(parents);
    self
  }

  pub fn parents(&self) -> Option<&Vec<String>> {
    self.parents.as_ref()
  }

  pub fn reset_parents(&mut self) {
    self.parents = None;
  }

  pub fn set_previous(&mut self, previous: String) {
    self.previous = Some(previous);
  }

  pub fn with_previous(mut self, previous: String) -> InscriptionResponse {
    self.previous = Some(previous);
    self
  }

  pub fn previous(&self) -> Option<&String> {
    self.previous.as_ref()
  }

  pub fn reset_previous(&mut self) {
    self.previous = None;
  }

  pub fn set_rune(&mut self, rune: String) {
    self.rune = Some(rune);
  }

  pub fn with_rune(mut self, rune: String) -> InscriptionResponse {
    self.rune = Some(rune);
    self
  }

  pub fn rune(&self) -> Option<&String> {
    self.rune.as_ref()
  }

  pub fn reset_rune(&mut self) {
    self.rune = None;
  }

  pub fn set_sat(&mut self, sat: String) {
    self.sat = Some(sat);
  }

  pub fn with_sat(mut self, sat: String) -> InscriptionResponse {
    self.sat = Some(sat);
    self
  }

  pub fn sat(&self) -> Option<&String> {
    self.sat.as_ref()
  }

  pub fn reset_sat(&mut self) {
    self.sat = None;
  }

  pub fn set_satpoint(&mut self, satpoint: String) {
    self.satpoint = Some(satpoint);
  }

  pub fn with_satpoint(mut self, satpoint: String) -> InscriptionResponse {
    self.satpoint = Some(satpoint);
    self
  }

  pub fn satpoint(&self) -> Option<&String> {
    self.satpoint.as_ref()
  }

  pub fn reset_satpoint(&mut self) {
    self.satpoint = None;
  }

  pub fn set_timestamp(&mut self, timestamp: i32) {
    self.timestamp = Some(timestamp);
  }

  pub fn with_timestamp(mut self, timestamp: i32) -> InscriptionResponse {
    self.timestamp = Some(timestamp);
    self
  }

  pub fn timestamp(&self) -> Option<&i32> {
    self.timestamp.as_ref()
  }

  pub fn reset_timestamp(&mut self) {
    self.timestamp = None;
  }

  pub fn set_value(&mut self, value: i32) {
    self.value = Some(value);
  }

  pub fn with_value(mut self, value: i32) -> InscriptionResponse {
    self.value = Some(value);
    self
  }

  pub fn value(&self) -> Option<&i32> {
    self.value.as_ref()
  }

  pub fn reset_value(&mut self) {
    self.value = None;
  }

}



