/* 
 * Satstream API
 *
 * Satstream API
 *
 * OpenAPI spec version: 1.0
 * Contact: team@satstream.io
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct ResponsesNonInscriptionUtxo {
  #[serde(rename = "address")]
  address: Option<String>,
  #[serde(rename = "codeType")]
  code_type: Option<i32>,
  #[serde(rename = "height")]
  height: Option<i32>,
  #[serde(rename = "idx")]
  idx: Option<i32>,
  #[serde(rename = "isOpInRBF")]
  is_op_in_rbf: Option<bool>,
  #[serde(rename = "isSpent")]
  is_spent: Option<bool>,
  #[serde(rename = "satoshi")]
  satoshi: Option<::models::BigInt>,
  #[serde(rename = "scriptPk")]
  script_pk: Option<String>,
  #[serde(rename = "scriptType")]
  script_type: Option<String>,
  #[serde(rename = "txid")]
  txid: Option<String>,
  #[serde(rename = "vout")]
  vout: Option<i32>
}

impl ResponsesNonInscriptionUtxo {
  pub fn new() -> ResponsesNonInscriptionUtxo {
    ResponsesNonInscriptionUtxo {
      address: None,
      code_type: None,
      height: None,
      idx: None,
      is_op_in_rbf: None,
      is_spent: None,
      satoshi: None,
      script_pk: None,
      script_type: None,
      txid: None,
      vout: None
    }
  }

  pub fn set_address(&mut self, address: String) {
    self.address = Some(address);
  }

  pub fn with_address(mut self, address: String) -> ResponsesNonInscriptionUtxo {
    self.address = Some(address);
    self
  }

  pub fn address(&self) -> Option<&String> {
    self.address.as_ref()
  }

  pub fn reset_address(&mut self) {
    self.address = None;
  }

  pub fn set_code_type(&mut self, code_type: i32) {
    self.code_type = Some(code_type);
  }

  pub fn with_code_type(mut self, code_type: i32) -> ResponsesNonInscriptionUtxo {
    self.code_type = Some(code_type);
    self
  }

  pub fn code_type(&self) -> Option<&i32> {
    self.code_type.as_ref()
  }

  pub fn reset_code_type(&mut self) {
    self.code_type = None;
  }

  pub fn set_height(&mut self, height: i32) {
    self.height = Some(height);
  }

  pub fn with_height(mut self, height: i32) -> ResponsesNonInscriptionUtxo {
    self.height = Some(height);
    self
  }

  pub fn height(&self) -> Option<&i32> {
    self.height.as_ref()
  }

  pub fn reset_height(&mut self) {
    self.height = None;
  }

  pub fn set_idx(&mut self, idx: i32) {
    self.idx = Some(idx);
  }

  pub fn with_idx(mut self, idx: i32) -> ResponsesNonInscriptionUtxo {
    self.idx = Some(idx);
    self
  }

  pub fn idx(&self) -> Option<&i32> {
    self.idx.as_ref()
  }

  pub fn reset_idx(&mut self) {
    self.idx = None;
  }

  pub fn set_is_op_in_rbf(&mut self, is_op_in_rbf: bool) {
    self.is_op_in_rbf = Some(is_op_in_rbf);
  }

  pub fn with_is_op_in_rbf(mut self, is_op_in_rbf: bool) -> ResponsesNonInscriptionUtxo {
    self.is_op_in_rbf = Some(is_op_in_rbf);
    self
  }

  pub fn is_op_in_rbf(&self) -> Option<&bool> {
    self.is_op_in_rbf.as_ref()
  }

  pub fn reset_is_op_in_rbf(&mut self) {
    self.is_op_in_rbf = None;
  }

  pub fn set_is_spent(&mut self, is_spent: bool) {
    self.is_spent = Some(is_spent);
  }

  pub fn with_is_spent(mut self, is_spent: bool) -> ResponsesNonInscriptionUtxo {
    self.is_spent = Some(is_spent);
    self
  }

  pub fn is_spent(&self) -> Option<&bool> {
    self.is_spent.as_ref()
  }

  pub fn reset_is_spent(&mut self) {
    self.is_spent = None;
  }

  pub fn set_satoshi(&mut self, satoshi: ::models::BigInt) {
    self.satoshi = Some(satoshi);
  }

  pub fn with_satoshi(mut self, satoshi: ::models::BigInt) -> ResponsesNonInscriptionUtxo {
    self.satoshi = Some(satoshi);
    self
  }

  pub fn satoshi(&self) -> Option<&::models::BigInt> {
    self.satoshi.as_ref()
  }

  pub fn reset_satoshi(&mut self) {
    self.satoshi = None;
  }

  pub fn set_script_pk(&mut self, script_pk: String) {
    self.script_pk = Some(script_pk);
  }

  pub fn with_script_pk(mut self, script_pk: String) -> ResponsesNonInscriptionUtxo {
    self.script_pk = Some(script_pk);
    self
  }

  pub fn script_pk(&self) -> Option<&String> {
    self.script_pk.as_ref()
  }

  pub fn reset_script_pk(&mut self) {
    self.script_pk = None;
  }

  pub fn set_script_type(&mut self, script_type: String) {
    self.script_type = Some(script_type);
  }

  pub fn with_script_type(mut self, script_type: String) -> ResponsesNonInscriptionUtxo {
    self.script_type = Some(script_type);
    self
  }

  pub fn script_type(&self) -> Option<&String> {
    self.script_type.as_ref()
  }

  pub fn reset_script_type(&mut self) {
    self.script_type = None;
  }

  pub fn set_txid(&mut self, txid: String) {
    self.txid = Some(txid);
  }

  pub fn with_txid(mut self, txid: String) -> ResponsesNonInscriptionUtxo {
    self.txid = Some(txid);
    self
  }

  pub fn txid(&self) -> Option<&String> {
    self.txid.as_ref()
  }

  pub fn reset_txid(&mut self) {
    self.txid = None;
  }

  pub fn set_vout(&mut self, vout: i32) {
    self.vout = Some(vout);
  }

  pub fn with_vout(mut self, vout: i32) -> ResponsesNonInscriptionUtxo {
    self.vout = Some(vout);
    self
  }

  pub fn vout(&self) -> Option<&i32> {
    self.vout.as_ref()
  }

  pub fn reset_vout(&mut self) {
    self.vout = None;
  }

}



